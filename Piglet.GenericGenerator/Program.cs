using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Piglet.GenericGenerator
{
    public static class Program
    {
        public static int MAX_SIZE = 16;


        public static void Main(string[] args)
        {
            Directory.SetCurrentDirectory(args[0]);

            FileInfo target_file = new FileInfo(args[1]);
            DirectoryInfo parent = target_file.Directory;

            if (!parent.Exists)
                parent.Create();

            if (args.Length > 2 && int.TryParse(args[2], out int size))
                MAX_SIZE = size;

            using FileStream stream = new FileStream(target_file.FullName, FileMode.Create, FileAccess.ReadWrite, FileShare.Read);
            using StreamWriter writer = new StreamWriter(stream);

            CreateGenericExtensions(writer);

            writer.Flush();
            stream.Flush();
        }

        private static void CreateGenericExtensions(StreamWriter writer)
        {
            static IEnumerable<int> range(int start, int count) => Enumerable.Range(start, count);

            writer.Write($@"
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED {DateTime.Now:yyyy-MM-dd HH:mm:ss.ffffff}              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Linq;
using System;

using Piglet.Parser.Construction;
using Piglet.Lexer.Runtime;


namespace Piglet.Parser.Configuration.Generic
{{
    public abstract class ParserConstructor<TOut>
    {{
        private ParserWrapper? _parser = null;
        private volatile int _ntcounter = 0;

        public IParserConfigurator<object> Configurator {{ get; }}


        public ParserConstructor()
            : this(ParserFactory.Configure<object>())
        {{
        }}

        public ParserConstructor(IParserConfigurator<object> configurator) => Configurator = configurator;

        protected NonTerminalWrapper<T> CreateNonTerminal<T>(string name) => new NonTerminalWrapper<T>(Configurator.CreateNonTerminal(name));

        protected NonTerminalWrapper<T> CreateNonTerminal<T>() => CreateNonTerminal<T>($""NT{{++_ntcounter}}"");

        protected TerminalWrapper<T> CreateTerminal<T>(string regex, Func<string, T> func) => new TerminalWrapper<T>(Configurator.CreateTerminal(regex, s => func(s)));

        protected TerminalWrapper<string> CreateTerminal(string regex) => new TerminalWrapper<string>(Configurator.CreateTerminal(regex));

        /// <summary>ascending precedence!</summary>
        protected void SetPrecedenceList(params (AssociativityDirection direction, ITerminalWrapper[] symbols)[] group)
        {{
            foreach ((AssociativityDirection d, ITerminalWrapper[] s) in group)
                SetAssociativity(d, s);
        }}

        protected IPrecedenceGroup SetAssociativity(AssociativityDirection dir, params ITerminalWrapper[] symbol)
        {{
            ITerminal<object>[] arr = symbol.Select(s => s.Symbol).ToArray();

            if (dir == AssociativityDirection.Left)
                return Configurator.LeftAssociative(arr);
            else if (dir == AssociativityDirection.Right)
                return Configurator.RightAssociative(arr);
            else
                throw new ArgumentException();
        }}

        protected void CreateProduction<T, S0>(NonTerminalWrapper<T> to, SymbolWrapper<S0> s) => to.AddProduction(s).SetReduceToFirst();
");

            for (int i = 0; i < MAX_SIZE; ++i)
            {
                string types = string.Concat(range(0, i).Select(x => $", S{x}"));
                string ftypes = string.Concat(range(0, i).Select(x => $"S{x}, "));
                string names = string.Join(", ", range(0, i).Select(x => $"s{x}"));
                string args = string.Concat(range(0, i).Select(x => $", SymbolWrapper<S{x}> s{x}"));

                writer.Write($@"
        protected ProductionWrapper<{ftypes}T> CreateProduction<T{types}>(NonTerminalWrapper<T> to{args}, Func<{ftypes}T> func) => to.AddProduction({names}).SetReduceFunction(func);
");
            }

            writer.Write($@"
        public ParserWrapper CreateParser()
        {{
            if (_parser is null)
            {{
                NonTerminalWrapper<TOut> nt = CreateNonTerminal<TOut>();

                Construct(nt);

                Configurator.SetStartSymbol((INonTerminal<object>)nt.Symbol);
                _parser = new ParserWrapper(Configurator.CreateParser());
            }}

            return _parser;
        }}

        protected abstract void Construct(NonTerminalWrapper<TOut> start_symbol);


        public sealed class ParserWrapper
        {{
            public IParser<object> Parser {{ get; }}


            internal ParserWrapper(IParser<object> parser) => Parser = parser;

            public ParserResult<TOut> Parse(string s)
            {{
                List<LexedToken<object>> tokens = new List<LexedToken<object>>();
                void aggregate(LexedToken<object> token)
                {{
                    tokens.Add(token);

                    if (token is LexedNonTerminal<object> nt)
                        foreach (LexedToken<object> child in nt.ChildNodes)
                            aggregate(child);
                }}

                aggregate(Parser.ParseTokens(s));

                return new ParserResult<TOut>((TOut)tokens[0].SymbolValue, s.Split('\n'), tokens.ToArray());
            }}
        }}
    }}

    public sealed class ParserResult<TOut>
    {{
        public TOut ParsedValue {{ get; }}
        public string[] SourceLines {{ get; }}
        public LexedToken<object>[] LexedTokens {{ get; }}


        internal ParserResult(TOut parsedValue, string[] sourceLines, LexedToken<object>[] lexedTokens)
        {{
            ParsedValue = parsedValue;
            SourceLines = sourceLines;
            LexedTokens = lexedTokens;
        }}

        public static implicit operator TOut(ParserResult<TOut> res) => res.ParsedValue;
    }}

    public interface ITerminalWrapper
    {{
        ITerminal<object> Symbol {{ get; }}
    }}

    public class SymbolWrapper<T>
    {{
        public ISymbol<object> Symbol {{ get; }}
        public Type SymbolType => typeof(T);


        public SymbolWrapper(ISymbol<object> symbol) => Symbol = symbol;

        public override string ToString() => Symbol.ToString();
    }}

    public sealed class TerminalWrapper<T>
        : SymbolWrapper<T>
        , ITerminalWrapper
    {{
        ITerminal<object> ITerminalWrapper.Symbol => (ITerminal<object>)Symbol;

        public TerminalWrapper(ISymbol<object> symbol)
            : base(symbol)
        {{
        }}
    }}

    public sealed class NonTerminalWrapper<T>
        : SymbolWrapper<T>
    {{
        public NonTerminalWrapper(ISymbol<object> symbol)
            : base(symbol)
        {{
        }}

        public ProductionWrapper<T> AddProduction() => new ProductionWrapper<T>(((INonTerminal<object>)Symbol).AddProduction());
");

            for (int i = 1; i < MAX_SIZE; ++i)
            {
                string types = string.Join(", ", range(0, i).Select(x => $"T{x}"));
                string names = string.Join(", ", range(0, i).Select(x => $"sym{x}.Symbol"));
                string args = string.Join(", ", range(0, i).Select(x => $"SymbolWrapper<T{x}> sym{x}"));

                writer.Write($@"
        public ProductionWrapper<{types}, T> AddProduction<{types}>({args}) =>
            new ProductionWrapper<{types}, T>(((INonTerminal<object>)Symbol).AddProduction({names}));
");
            }

            writer.Write($@"
    }}

    public abstract class ProductionWrapperBase<T>
        where T : ProductionWrapperBase<T>
    {{
        public IProduction<object> Production {{ get; }}


        public ProductionWrapperBase(IProduction<object> production) => Production = production;

        public void SetReduceToFirst() => Production.SetReduceToFirst();

        public void SetPrecedence(IPrecedenceGroup precedence) => Production.SetPrecedence(precedence);
    }}
");
            for (int i = 1; i <= MAX_SIZE; ++i)
            {
                IEnumerable<string> types = range(0, i).Select(x => x == i - 1 ? "R" : $"T{x}");
                string typestr = string.Join(", ", types);

                writer.Write($@"

    public sealed class ProductionWrapper<{typestr}>
        : ProductionWrapperBase<ProductionWrapper<{typestr}>>
    {{
        public ProductionWrapper<{typestr}> SetReduceFunction(Func<{typestr}> f)
        {{
            Production.SetReduceFunction(args => f({string.Join(", ", types.Take(i - 1).Select((x, i) => $"({x})args[{i}]"))}));

            return this;
        }}

        public ProductionWrapper(IProduction<object> production)
            : base(production)
        {{
        }}
    }}
");
            }

            writer.WriteLine("}");
        }
    }
}
