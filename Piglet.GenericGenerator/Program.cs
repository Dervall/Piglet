using System.Collections.Generic;
using System.Linq;
using System.IO;
using System;

namespace Piglet.GenericGenerator
{
    public static class Program
    {
        public static int MAX_SIZE = 16;


        public static int Main(string[] args)
        {
            if (args.Length < 2)
            {
                Console.Error.WriteLine($@"Usage:
    {new FileInfo(typeof(Program).Assembly.Location).Name} <target-file> <type> [size]

Arguments:
    target-file     The path to the target .cs or .fs file which will contain the generated classes.
    type            'cs' or 'fs'. This determines it generates the C# or F# helper classes.
    size            Number of classes/production wrappers to generate.
");

                return -1;
            }

            FileInfo target_file = new FileInfo(args[0]);
            DirectoryInfo parent = target_file.Directory;

            if (!parent.Exists)
                parent.Create();

            if (args.Length > 2 && int.TryParse(args[2], out int size))
                MAX_SIZE = size;

            if (target_file.Exists)
                target_file.Delete();

            using FileStream stream = new FileStream(target_file.FullName, FileMode.Create, FileAccess.ReadWrite, FileShare.ReadWrite | FileShare.Delete);
            using StreamWriter writer = new StreamWriter(stream);

            switch (args[1].ToLowerInvariant())
            {
                case "cs":
                    CreateGenericExtensions(writer);

                    break;
                case "fs":
                    CreateFSharpExtensions(writer);

                    break;
                default:
                    Console.Error.WriteLine($"Invalid output type '{args[1]}'. Expected 'cs' or 'fs'.");

                    return -1;
            }

            writer.Flush();
            stream.Flush();

            return 0;
        }

        private static void CreateGenericExtensions(StreamWriter writer)
        {
            writer.Write($@"
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED {DateTime.Now:yyyy-MM-dd HH:mm:ss.ffffff}              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Diagnostics.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System;

using Piglet.Parser.Construction;
using Piglet.Lexer.Runtime;
using Piglet.Lexer;


namespace Piglet.Parser.Configuration.Generic
{{
    /// <summary>
    /// Represents an abstract generic parser constructor.
    /// <para/>
    /// The parser based on this constructor will return a parsed value of the type <typeparamref name=""TOut""/>.
    /// </summary>
    /// <typeparam name=""TOut"">The generic value return type of the parser.</typeparam>
    public abstract class ParserConstructor<TOut>
    {{
        private ParserWrapper? _parser = null;
        private volatile int _ntcounter = 0;

        /// <summary>
        /// The parser configuration.
        /// </summary>
        public IParserConfigurator<object> Configurator {{ get; }}


        /// <summary>
        /// Creates a new generic parser constructor with the default parser configuration.
        /// </summary>
        public ParserConstructor()
            : this(ParserFactory.Configure<object>())
        {{
        }}

        /// <summary>
        /// Creates a new generic parser constructor with the given parser configuration.
        /// </summary>
        /// <param name=""configurator"">Parser configuration.</param>
        public ParserConstructor(IParserConfigurator<object> configurator) => Configurator = configurator;

        /// <summary>
        /// Creates a new non-terminal symbol with the given generic semantic value and name.
        /// </summary>
        /// <typeparam name=""T"">Generic semantic value stored inside the new non-terminal symbol.</typeparam>
        /// <param name=""name"">The name of the new non-terminal symbol.</param>
        /// <returns>The newly created non-terminal symbol.</returns>
        protected NonTerminalWrapper<T> CreateNonTerminal<T>(string name) => new NonTerminalWrapper<T>(Configurator.CreateNonTerminal(name));

        /// <summary>
        /// Creates a new non-terminal symbol with the given generic semantic value and the default name for non-terminals (""NT..."").
        /// </summary>
        /// <typeparam name=""T"">Generic semantic value stored inside the new non-terminal symbol.</typeparam>
        /// <returns>The newly created non-terminal symbol.</returns>
        protected NonTerminalWrapper<T> CreateNonTerminal<T>() => CreateNonTerminal<T>($""NT{{++_ntcounter}}"");

        /// <summary>
        /// Creates a new terminal symbol associated with the given regex string and generic value.
        /// </summary>
        /// <typeparam name=""T"">Generic semantic value stored inside the new terminal symbol.</typeparam>
        /// <param name=""regex"">The regex string associated with the terminal symbol.</param>
        /// <param name=""value"">The value stored inside the new terminal value.</param>
        /// <returns>The newly created terminal symbol.</returns>
        protected TerminalWrapper<T> CreateTerminal<T>(string regex, T value) => CreateTerminal(regex, _ => value);

        /// <summary>
        /// Creates a new terminal symbol associated with the given regex string and the function providing the generic value.
        /// </summary>
        /// <typeparam name=""T"">Generic semantic value stored inside the new terminal symbol.</typeparam>
        /// <param name=""regex"">The regex string associated with the terminal symbol.</param>
        /// <param name=""func"">The function providing the generic value represented by the terminal symbol.</param>
        /// <returns>The newly created terminal symbol.</returns>
        protected TerminalWrapper<T> CreateTerminal<T>(string regex, Func<string, T> func) => new TerminalWrapper<T>(Configurator.CreateTerminal(regex, s => func(s)));

        /// <summary>
        /// Creates a new terminal symbol associated with the given regex string and the identity function (of the type <see langword=""string""/>).
        /// </summary>
        /// <param name=""regex"">The regex string associated with the terminal symbol.</param>
        /// <returns>The newly created terminal symbol.</returns>
        protected TerminalWrapper<string> CreateTerminal(string regex) => new TerminalWrapper<string>(Configurator.CreateTerminal(regex));

        /// <summary>
        /// Sets the precedence for all given symbols in ascending order. The first symbol group is therefore considered to have the lowest precedence and the last symbol group the highest precedence.
        /// </summary>
        /// <param name=""groups"">Ordered collection of groups containing a set of symbols with their corresponding associativity.</param>
        protected void SetPrecedenceList(params (AssociativityDirection direction, ITerminalWrapper[] symbols)[] groups)
        {{
            foreach ((AssociativityDirection d, ITerminalWrapper[] s) in groups)
                SetAssociativity(d, s);
        }}

        /// <summary>
        /// Sets the given associativity to all symbols in the given symbol collection. All sybols will be considered to have the same precedence group.
        /// </summary>
        /// <param name=""dir"">Associativity direction.</param>
        /// <param name=""symbols"">Target symbols.</param>
        /// <returns>The precedence group associated with the given symbols.</returns>
        protected IPrecedenceGroup SetAssociativity(AssociativityDirection dir, params ITerminalWrapper[] symbols)
        {{
            ITerminal<object>[] arr = symbols.Select(s => s.Symbol).ToArray();

            switch (dir)
            {{
                case AssociativityDirection.Left:
                    return Configurator.LeftAssociative(arr);
                case AssociativityDirection.Right:
                    return Configurator.RightAssociative(arr);
                default:
                    throw new ArgumentOutOfRangeException(nameof(dir));
            }}
        }}

        /// <summary>
        /// Creates a new production rule on the given non-terminal symbol using the given production function.
        /// <br/>
        /// This production represents the reducing of the given non-terminal to the given symbol.
        /// </summary>
        /// <typeparam name=""T"">The generic type of <paramref name=""non_terminal""/>.</typeparam>
        /// <typeparam name=""S0"">The generic type of <paramref name=""non_terminal""/>.</typeparam>
        /// <param name=""non_terminal"">The non-terminal symbol which gets reduced.</param>
        /// <param name=""symbol0"">The symbol, to which <paramref name=""non_terminal""/> gets reduced.</param>
        protected void CreateProduction<T, S0>(NonTerminalWrapper<T> non_terminal, SymbolWrapper<S0> symbol0) => non_terminal.AddProduction(symbol0).SetReduceToFirst();
");

            for (int i = 0; i <= MAX_SIZE; ++i)
            {
                string types = string.Concat(range(0, i).Select(x => $", S{x}"));
                string ftypes = string.Concat(range(0, i).Select(x => $"S{x}, "));
                string names = string.Join(", ", range(0, i).Select(x => $"symbol{x}"));
                string args = string.Concat(range(0, i).Select(x => $", SymbolWrapper<S{x}> symbol{x}"));

                writer.Write($@"
        /// <summary>
        /// Creates a new production rule on the given non-terminal symbol using the given production function.
        /// <br/>
        /// This production represents the reducing of the given non-terminal to the {i} given symbols.
        /// </summary>
        /// <param name=""non_terminal"">The non-terminal symbol which gets reduced.</param>
        /// <typeparam name=""T"">The generic type of <paramref name=""non_terminal""/>.</typeparam>");

                for (int j = 0; j < i; ++j)
                    writer.Write($@"
        /// <typeparam name=""S{j}"">The generic type of <paramref name=""symbol{j}""/>.</typeparam>");

                for (int j = 0; j < i; ++j)
                    writer.Write($@"
        /// <param name=""symbol{j}"">The symbol no. {j}, to which the current non-terminal symbol gets reduced.</param>");

                writer.Write($@"
        /// <param name=""func"">The generic production function which gets called upon reduction. The function accepts the value stored inside the produced symbols, and returns the value to be stored inside the non-terminal symbol ""<paramref name=""non_terminal""/>"".</param>
        /// <returns>The newly created production rule.</returns>
        protected ProductionWrapper<{ftypes}T> CreateProduction<T{types}>(NonTerminalWrapper<T> non_terminal{args}, Func<{ftypes}T> func) => non_terminal.AddProduction({names}).SetReduceFunction(func);
");
            }

            writer.Write(@"
        /// <summary>
        /// Creates a new parser based on the current configurator and returns it.
        /// <para/>
        /// <b>Note:</b> Only the first call of <see cref=""CreateParser""/> creates a new parser. If you wish to reset the generated parser and re-create it, call the method <see cref=""ReesetParser""/> beforehand.
        /// </summary>
        /// <returns>The constructed parser.</returns>
        public ParserWrapper CreateParser()
        {
            if (_parser is null)
            {
                NonTerminalWrapper<TOut> nt = CreateNonTerminal<TOut>();

                Construct(nt);

                Configurator.SetStartSymbol((INonTerminal<object>)nt.Symbol);
                _parser = new ParserWrapper(Configurator.CreateParser());
            }

            return _parser;
        }

        /// <summary>
        /// Resets the constructed parser to <see langword=""null""/>, thereby forcing the parser to be re-constructed based on the current conficuration the next time <see cref=""CreateParser""/> is called.
        /// </summary>
        public void ResetParser() => _parser = null;

        /// <summary>
        /// Constructs the parser. This method must be implemented by every constructor based on <see cref=""ParserConstructor{TOut}""/>
        /// </summary>
        /// <param name=""start_symbol"">The non-terminal production start symbol. The value of this symbol will be returned when the constructed parser is executed.</param>
        protected abstract void Construct(NonTerminalWrapper<TOut> start_symbol);


        /// <summary>
        /// Represents a wrapper for the generic parser.
        /// </summary>
        public sealed class ParserWrapper
        {
            /// <summary>
            /// The internal parser instance.
            /// </summary>
            public IParser<object> Parser { get; }


            internal ParserWrapper(IParser<object> parser) => Parser = parser;

            /// <summary>
            /// Tries to parse the given string and returns whether the parsing was successful.
            /// </summary>
            /// <param name=""input"">The input string.</param>
            /// <param name=""result"">The parsed value.</param>
            public bool TryParse(string input, [MaybeNullWhen(false)] out ParserResult<TOut>? result)
            {
                try
                {
                    result = Parse(input);
                }
                catch (LexerException)
                {
                    result = null;
                }

                return result is { };
            }

            /// <summary>
            /// Parses the given string and returns the parsed value of the type <typeparamref name=""TOut""/>.
            /// </summary>
            /// <param name=""input"">The input string.</param>
            /// <returns>The parsed value.</returns>
            public ParserResult<TOut> Parse(string input)
            {
                List<LexedToken<object>> tokens = new List<LexedToken<object>>();
                void aggregate(LexedToken<object> token)
                {
                    tokens.Add(token);

                    if (token is LexedNonTerminal<object> nt)
                        foreach (LexedToken<object> child in nt.ChildNodes)
                            aggregate(child);
                }

                aggregate(Parser.ParseTokens(input));

                return new ParserResult<TOut>((TOut)tokens[0].SymbolValue, input.Split('\n'), tokens.ToArray());
            }
        }
    }

    public sealed class ParserResult<TOut>
    {
        public TOut ParsedValue { get; }
        public string[] SourceLines { get; }
        public LexedToken<object>[] LexedTokens { get; }


        internal ParserResult(TOut parsedValue, string[] sourceLines, LexedToken<object>[] lexedTokens)
        {
            ParsedValue = parsedValue;
            SourceLines = sourceLines;
            LexedTokens = lexedTokens;
        }

        public static implicit operator TOut(ParserResult<TOut> res) => res.ParsedValue;
    }

    /// <summary>
    /// An interface for generic terminal wrappers.
    /// </summary>
    public interface ITerminalWrapper
    {
        /// <summary>
        /// The underlying terminal symbol.
        /// </summary>
        ITerminal<object> Symbol { get; }
    }

    /// <summary>
    /// Represents a generic symbol wrapper.
    /// </summary>
    /// <typeparam name=""T"">The generic type stored inside the symbol.</typeparam>
    public class SymbolWrapper<T>
    {
        /// <summary>
        /// The underlying (boxed) symbol.
        /// </summary>
        public ISymbol<object> Symbol { get; }
        /// <summary>
        /// The type of the generic value stored inside the symbol.
        /// </summary>
        public Type SymbolType => typeof(T);


        /// <summary>
        /// Creates a new generic symbol wrapper for the given (boxed) symbol.
        /// </summary>
        /// <param name=""symbol"">Boxed symbol.</param>
        public SymbolWrapper(ISymbol<object> symbol) => Symbol = symbol;

        /// <inheritdoc/>
        public override string? ToString() => Symbol.ToString();
    }

    /// <summary>
    /// Represents a generic terminal symbol wrapper.
    /// </summary>
    /// <inheritdoc/>
    /// <typeparam name=""T"">The generic type stored inside the symbol.</typeparam>
    public sealed class TerminalWrapper<T>
        : SymbolWrapper<T>
        , ITerminalWrapper
    {
        /// <inheritdoc/>
        ITerminal<object> ITerminalWrapper.Symbol => (ITerminal<object>)Symbol;

        /// <summary>
        /// Creates a new generic symbol wrapper for the given (boxed) terminal symbol.
        /// </summary>
        /// <param name=""symbol"">Boxed terminal symbol.</param>
        public TerminalWrapper(ISymbol<object> symbol)
            : base(symbol)
        {
        }
    }

    /// <summary>
    /// Represents a generic non-terminal symbol wrapper.
    /// </summary>
    /// <inheritdoc/>
    /// <typeparam name=""T"">The generic type stored inside the symbol.</typeparam>
    public sealed class NonTerminalWrapper<T>
        : SymbolWrapper<T>
    {
        /// <summary>
        /// Creates a new generic symbol wrapper for the given (boxed) non-terminal symbol.
        /// </summary>
        /// <param name=""symbol"">Boxed non-terminal symbol.</param>
        public NonTerminalWrapper(ISymbol<object> symbol)
            : base(symbol)
        {
        }

        /// <summary>
        /// Creates a new (empty) production rule on the current non-terminal symbol and returns it.
        /// </summary>
        /// <returns>The newly created production rule.</returns>
        public ProductionWrapper<T> AddProduction() => new ProductionWrapper<T>(((INonTerminal<object>)Symbol).AddProduction());
");

            for (int i = 1; i <= MAX_SIZE; ++i)
            {
                string types = string.Join(", ", range(0, i).Select(x => $"T{x}"));
                string names = string.Join(", ", range(0, i).Select(x => $"sym{x}.Symbol"));
                string args = string.Join(", ", range(0, i).Select(x => $"SymbolWrapper<T{x}> sym{x}"));

                writer.Write($@"
        /// <summary>
        /// Creates a new production rule on the current non-terminal symbol.
        /// <br/>
        /// This production represents the reducing of the current non-terminal to the {i} given symbols.
        /// </summary>");

                for (int j = 0; j < i; ++j)
                    writer.Write($@"
        /// <typeparam name=""T{j}"">The generic type of <paramref name=""sym{j}""/>.</typeparam>");

                for (int j = 0; j < i; ++j)
                    writer.Write($@"
        /// <param name=""sym{j}"">The symbol no. {j}, to which the current non-terminal symbol gets reduced.</param>");

                writer.Write($@"
        /// <returns>The newly created production rule.</returns>
        public ProductionWrapper<{types}, T> AddProduction<{types}>({args}) =>
            new ProductionWrapper<{types}, T>(((INonTerminal<object>)Symbol).AddProduction({names}));
");
            }

            writer.Write(@"
    }

    /// <summary>
    /// Represents an abstract generic production wrapper.
    /// </summary>
    /// <typeparam name=""T"">The generic return type of the production. This is the type stored inside the non-terminal which gets reduced by the production represented by this wrapper.</typeparam>
    public abstract class ProductionWrapperBase<T>
        where T : ProductionWrapperBase<T>
    {
        /// <summary>
        /// The underlying (boxed) production of this wrapper.
        /// </summary>
        public IProduction<object> Production { get; }


        /// <summary>
        /// Creates a new abstract generic production wrapper based on the given (boxed) production.
        /// </summary>
        /// <param name=""production"">Boxed production instance.</param>
        public ProductionWrapperBase(IProduction<object> production) => Production = production;

        /// <summary>
        /// Configures the production to reduce the non-terminal to the first symbol. This is equivalent to <see cref=""IProduction{T}.SetReduceToIndex(int)""/> with the index 0.
        /// </summary>
        /// <returns>The current instance.</returns>
        public T SetReduceToFirst()
        {
            Production.SetReduceToFirst();

            return (T)this;
        }

        /// <summary>
        /// Sets given precedence group to the current production.
        /// </summary>
        /// <param name=""precedence"">Precedence group to the assigned to the current production.</param>
        /// <returns>The current instance.</returns>
        public T SetPrecedence(IPrecedenceGroup precedence)
        {
            Production.SetPrecedence(precedence);

            return (T)this;
        }
    }
");
            for (int i = 1; i <= MAX_SIZE + 1; ++i)
            {
                IEnumerable<string> types = range(0, i).Select(x => x == i - 1 ? "R" : $"T{x}");
                string typestr = string.Join(", ", types);

                writer.Write($@"
    /// <summary>
    /// Represents a generic reduce function of the type ""<c>({typestr}) -&gt; <typeparamref name=""R""/></c>"".
    /// </summary>
    /// <inheritdoc/>");

                for (int j = 0; j < i - 1; ++j)
                    writer.Write($@"
    /// <typeparam name=""T{j}"">The generic input type of the symbol no. {j}.</typeparam>");

                writer.Write($@"
    /// <typeparam name=""R"">The generic return type of the production.</typeparam>
    public sealed class ProductionWrapper<{typestr}>
        : ProductionWrapperBase<ProductionWrapper<{typestr}>>
    {{
        /// <summary>
        /// Creates a new generic production wrapper based on the given (boxed) production.
        /// </summary>
        /// <inheritdoc/>
        /// <param name=""production"">Boxed production instance.</param>
        public ProductionWrapper(IProduction<object> production)
            : base(production)
        {{
        }}

        public ProductionWrapper<{typestr}> SetReduceFunction(Func<{typestr}> f)
        {{
            Production.SetReduceFunction(args => f({string.Join(", ", types.Take(i - 1).Select((x, i) => $"({x})args[{i}]"))}));

            return this;
        }}
    }}
");
            }

            writer.WriteLine("}");
        }

        private static void CreateFSharpExtensions(StreamWriter writer)
        {
            writer.Write($@"
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED {DateTime.Now:yyyy-MM-dd HH:mm:ss.ffffff}              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

namespace Piglet.Parser.Configuration.FSharp

open Piglet.Parser.Configuration.Generic
open System


type ParserConstructor<'TOut> with
    // TODO : ?
    end

/// A module containing F# code extensions for the namespace 'Piglet.Parser.Configuration.Generic'.
[<AutoOpen>]
module FSharpExtensions =
    
    /// <summary>
    /// Creates a new production rule to reduce the given symbol '<paramref name=""start""/>' into a constant provided by the function '<paramref name=""func""/>'.
    /// <para/>
    /// This function returns the newly created production rule. To discard the return value, either use ""|> ignore"" or use the function <see ref=""reduce_ci""/>.
    /// </summary>
    /// <param name=""start"">The start symbol for this production.</param>
    /// <param name=""func"">The reduce function.</param>
    /// <return>The newly created production rule.</return>
    let reduce_c (start : NonTerminalWrapper<'a>) func = start.AddProduction().SetReduceFunction(Func<'a>(func))

    /// <summary>
    /// Creates a new production rule to reduce the given symbol '<paramref name=""start""/>' into a constant provided by the function '<paramref name=""func""/>'.
    /// <para/>
    /// This function does not returns the newly created production rule. Use the function <see ref=""reduce_c""/> if you intend to reference the production rule.
    /// </summary>
    /// <param name=""start"">The start symbol for this production.</param>
    /// <param name=""func"">The reduce function.</param>
    let reduce_ci (start : NonTerminalWrapper<'a>) func = ignore <| reduce_c start func

    /// <summary>
    /// Creates a new production rule to reduce the given symbol '<paramref name=""start""/>' to the given symbol '<paramref name=""symbol""/>' using an identity mapping.
    /// <para/>
    /// This function returns the newly created production rule. To discard the return value, either use ""|> ignore"" or use the function <see ref=""reduce_0i""/>.
    /// </summary>
    /// <param name=""start"">The start symbol for this production.</param>
    /// <param name=""symbol"">The reduced symbol.</param>
    /// <return>The newly created production rule.</return>
    let reduce_0 (start : NonTerminalWrapper<'a>) symbol = start.AddProduction(symbol).SetReduceToFirst()

    /// <summary>
    /// Creates a new production rule to reduce the given symbol '<paramref name=""start""/>' to the given symbol '<paramref name=""symbol""/>' using an identity mapping.
    /// <para/>
    /// This function does not returns the newly created production rule. Use the function <see ref=""reduce_0""/> if you intend to reference the production rule.
    /// </summary>
    /// <param name=""start"">The start symbol for this production.</param>
    /// <param name=""symbol"">The reduced symbol.</param>
    /// <return>The newly created production rule.</return>
    let reduce_0i (start : NonTerminalWrapper<'a>) symbol = ignore <| reduce_0 start symbol
");

            for (int i = 1; i <= MAX_SIZE; ++i)
            {
                string[] variables = range(1, i).Select(x => "symbol" + x).ToArray();

                writer.Write($@"
    /// <summary>
    /// Creates a new production rule to reduce the given symbol '<paramref name=""start""/>' to the given {i} symbol(s) using the given production function.
    /// <para/>
    /// This function returns the newly created production rule. To discard the return value, either use ""|> ignore"" or use the function <see ref=""reduce_{i}i""/>.
    /// </summary>
    /// <param name=""start"">The start symbol for this production.</param
    /// <param name=""func"">The reduce function.</param>
    /// <return>The newly created production rule.</return>
    let reduce_{i} (start : NonTerminalWrapper<'a>) {string.Join(" ", variables)} func =
        start.AddProduction({string.Join(", ", variables)}).SetReduceFunction(Func<{string.Join(", ", Enumerable.Repeat('_', i))}, 'a>(func))


    /// <summary>
    /// Creates a new production rule to reduce the given symbol '<paramref name=""start""/>' to the given {i} symbol(s) using the given production function.
    /// <para/>
    /// This function does not returns the newly created production rule. Use the function <see ref=""reduce_{i}""/> if you intend to reference the production rule.
    /// </summary>
    /// <param name=""start"">The start symbol for this production.</param>
    /// <param name=""func"">The reduce function.</param>
    /// <return>The newly created production rule.</return>
    let reduce_{i}i (start : NonTerminalWrapper<'a>) {string.Join(" ", variables)} func =
        reduce_{i} start {string.Join(" ", variables)} func |> ignore
");
            }
        }

        private static IEnumerable<int> range(int start, int count) => Enumerable.Range(start, count);
    }
}
