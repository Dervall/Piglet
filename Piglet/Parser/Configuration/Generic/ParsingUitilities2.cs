
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED 2020-06-07 20:40:33.556784              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Linq;
using System;

using Piglet.Parser.Construction;
using Piglet.Lexer.Runtime;


namespace Piglet.Parser.Configuration.Generic
{
    public abstract class ParserConstructor<TOutput>
    {
        private ParserWrapper? _parser = null;
        private volatile int _ntcounter = 0;

        public IParserConfigurator<object> Configurator { get; }


        public ParserConstructor()
            : this(ParserFactory.Configure<object>())
        {
        }

        public ParserConstructor(IParserConfigurator<object> configurator) => Configurator = configurator;

        protected NonTerminalWrapper<T> CreateNonTerminal<T>(string name) => new NonTerminalWrapper<T>(Configurator.CreateNonTerminal(name));

        protected NonTerminalWrapper<T> CreateNonTerminal<T>() => CreateNonTerminal<T>($"NT{++_ntcounter}");

        protected TerminalWrapper<T> CreateTerminal<T>(string regex, Func<string, T> func) => new TerminalWrapper<T>(Configurator.CreateTerminal(regex, s => func(s)));

        protected TerminalWrapper<string> CreateTerminal(string regex) => new TerminalWrapper<string>(Configurator.CreateTerminal(regex));

        /// <summary>ascending precedence!</summary>
        protected void SetPrecedenceList(params (AssociativityDirection direction, ITerminalWrapper[] symbols)[] group)
        {
            foreach ((AssociativityDirection d, ITerminalWrapper[] s) in group)
                SetAssociativity(d, s);
        }

        protected IPrecedenceGroup SetAssociativity(AssociativityDirection dir, params ITerminalWrapper[] symbol)
        {
            ITerminal<object>[] arr = symbol.Select(s => s.Symbol).ToArray();

            if (dir == AssociativityDirection.Left)
                return Configurator.LeftAssociative(arr);
            else if (dir == AssociativityDirection.Right)
                return Configurator.RightAssociative(arr);
            else
                throw new ArgumentException();
        }
    }
}

