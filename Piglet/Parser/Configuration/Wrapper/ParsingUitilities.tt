<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    const int maxsize = 16;

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);
#>
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Collections.Generic;
using System.Linq;
using System;

using Piglet.Parser.Construction;


namespace Piglet.Parser.Configuration.Wrapper
{
    public abstract class LexerConstructor
    {
        public IParserConfigurator<object> Configurator { get; }
        private int _ntcounter = 0;


        public LexerConstructor()
            : this(ParserFactory.Configure<object>())
        {
        }

        public LexerConstructor(IParserConfigurator<object> configurator)
        {
        }

        public NonTerminalWrapper<T> CreateNonTerminal<T>()
        {
            lock (this)
                return new NonTerminalWrapper<T>(Configurator.CreateNonTerminal($"NT{++_ntcounter}"));
        }

        public TerminalWrapper<T> CreateTerminal<T>(string regex, Func<string, T> func) => new TerminalWrapper<T>(Configurator.CreateTerminal(regex, s => func(s)));

        public TerminalWrapper<string> CreateTerminal<T>(string regex) => new TerminalWrapper<string>(Configurator.CreateTerminal(regex));

        public void SetAssociativity(AssociativityDirection dir, params ITerminalWrapper[] symbol)
        {
            ITerminal<object>[] arr = symbol.Select(s => s.Symbol).ToArray();

            if (dir == AssociativityDirection.Left)
                Configurator.LeftAssociative(arr);
            else if (dir == AssociativityDirection.Right)
                Configurator.RightAssociative(arr);
        }

        public void CreateProduction<T, S0>(NonTerminalWrapper<T> to, SymbolWrapper<S0> s) => to.AddProduction(s).SetReduceToFirst();
<#
    for (int i = 0; i < maxsize; ++i)
    {
        string types = string.Concat(r(0, i).Select(x => $", S{x}"));
        string ftypes = string.Concat(r(0, i).Select(x => $"S{x}, "));
        string names = string.Join(", ", r(0, i).Select(x => $"s{x}"));
        string args = string.Concat(r(0, i).Select(x => $", SymbolWrapper<S{x}> s{x}"));
#>

        public void CreateProduction<T<#=types#>>(NonTerminalWrapper<T> to<#=args#>, Func<<#=ftypes#>T> func) => to.AddProduction(<#=names#>).SetReduceFunction(func);
<#
    }
#>

        public ParserWrapper<T> CreateParser<T>() => new ParserWrapper<T>(Configurator.CreateParser());

        public abstract void Construct();


        public sealed class ParserWrapper<T>
        {
            public IParser<object> Parser { get; }


            internal ParserWrapper(IParser<object> parser) => Parser = parser;

            public T Parse(string s) => (T)Parser.Parse(s);
        }
    }

    public interface ITerminalWrapper
    {
        ITerminal<object> Symbol { get; }
    }

    public class SymbolWrapper<T>
    {
        public ISymbol<object> Symbol { get; }
        public Type SymbolType => typeof(T);


        public SymbolWrapper(ISymbol<object> symbol) => Symbol = symbol;
    }

    public sealed class TerminalWrapper<T>
        : SymbolWrapper<T>
    {
        public TerminalWrapper(ISymbol<object> symbol)
            : base(symbol)
        {
        }
    }

    public sealed class NonTerminalWrapper<T>
        : SymbolWrapper<T>
        , ITerminalWrapper
    {
        ITerminal<object> ITerminalWrapper.Symbol => (ITerminal<object>)Symbol;

        public NonTerminalWrapper(ISymbol<object> symbol)
            : base(symbol)
        {
        }

        public ProductionWrapper<T> AddProduction() => new ProductionWrapper<T>(((INonTerminal<object>)Symbol).AddProduction());
<#
    for (int i = 1; i < maxsize; ++i)
    {
        string types = string.Join(", ", r(0, i).Select(x => $"T{x}"));
        string names = string.Join(", ", r(0, i).Select(x => $"sym{x}.Symbol"));
        string args = string.Join(", ", r(0, i).Select(x => $"SymbolWrapper<T{x}> sym{x}"));
#>

        public ProductionWrapper<<#=types#>, T> AddProduction<<#=types#>>(<#=args#>) =>
            new ProductionWrapper<<#=types#>, T>(((INonTerminal<object>)Symbol).AddProduction(<#=names#>));
<#
    }
#>
    }

    public abstract class ProductionWrapperBase
    {
        public IProduction<object> Production { get; }


        public ProductionWrapperBase(IProduction<object> production) => Production = production;

        public void SetReduceToFirst() => Production.SetReduceToFirst();

        public void SetPrecedence(IPrecedenceGroup precedence) => Production.SetPrecedence(precedence);
    }
<#
    for (int i = 1; i <= maxsize; ++i)
    {
        var types = r(0, i).Select(x => x == i - 1 ? "R" : $"T{x}");
        var tstr = string.Join(", ", types);
#>

    public sealed class ProductionWrapper<<#=tstr#>>
        : ProductionWrapperBase
    {
        public void SetReduceFunction(Func<<#=tstr#>> f) => Production.SetReduceFunction(o => f(<#=string.Join(", ", types.Take(i - 1).Select((x, i) => $"({x})o[{i}]"))#>));

        public ProductionWrapper(IProduction<object> production)
            : base(production)
        {
        }
    }
<#
    }
#>
}
